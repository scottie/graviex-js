//Scott Lindh 2018
//JS implimentation of the Graviex API
//
//
/////

var exports = module.exports = {};
var request = require('request');
var crypto = require('crypto');

var accessKey = "";//Your Graviex access key.
exports.accessKey = exports.accessKey;
var secretKey = "";
exports.secretKey = exports.secretKey;
var tonce;	//tonce is a timestamp in integer, stands for milliseconds elapsed since Unix epoch. Tonce must be within 30 seconds of server's current time. Each tonce can only be used once.
var signature;	//Signature of the API request, generated by you, use your secret key

//tonce
exports.tonce = function(callback){
	var timeStampInMs = new Date().getTime();
	return callback(timeStampInMs);
};

//Make GET request to API
/*
.apiRequest(function(result){
	if(result.success){
		console.log(result.message);
	}else{
		console.log(result.error);	
	}
})
*/
exports.apiRequest = function(uri, callback){
	var url = 'https://graviex.net/api/v2/' + uri;
	//console.log(url);
	request.get(url, function (error, response, body) {
    if(error){
 			return callback({success:false, error:error});
		}else{
			return callback({success:true, message:body});
		}
	  //console.log('error:', error);
	  //console.log('statusCode:', response && response.statusCode); 
	  //console.log('body:', body);
	});
};

//Make POST request to API
/*
apiPostRequest(function(result){
	if(result.success){
		console.log(result.message);
	}else{
		console.log(result.error);	
	}
})
*/
exports.apiPostRequest = function(uri, payload, callback){
	var url = 'https://graviex.net/api/v2/' + uri;
	//console.log(url);
	request.post(url, {form:{signature:payload}}, function (error, response, body) {
    if(error){
 			return callback({success:false, error:error});
		}else{
			return callback({success:true, message:body});
		}
	  //console.log('error:', error);
	  //console.log('statusCode:', response && response.statusCode); 
	  //console.log('body:', body);
	});
};


//Creates / Encrypts payload for the API
/*
genPayload("/api/v2/markets", function(payload){
	console.log(payload);
});
*/
exports.genPayload = function(requestType, uri, extras, callback){
	exports.tonce(function(tonce){
		var payload = requestType + "|" + uri + "|access_key=" + exports.accessKey + extras + "&tonce=" + tonce;
		//console.log("Payload: " + payload);
		var hash = crypto.createHmac('sha256', exports.secretKey).update(payload).digest('hex');
		return callback(hash, tonce);
	});
};

exports.genPayloadNoTONCE = function(requestType, uri, extras, callback){
	var payload = requestType + "|" + uri + "|" + extras;
	//console.log("Payload: " + payload);
	var hash = crypto.createHmac('sha256', exports.secretKey).update(payload).digest('hex');
	return callback(hash);
};

/////////////////////////////////////
///// Main Usage FunctionsUsage://///
/////////////////////////////////////

//listMarkets
//Get all available markets
/*
listMarkets(function(res){
	if(!res.error){
		//console.log(res);
		for (var key in res) {
			if (res.hasOwnProperty(key)) {
				console.log(res[key]);
			}
			}
	}else{
		console.log("ERROR: " + res)
	}
});
*/
exports.listMarkets = function(callback){
	exports.genPayload("GET", "/api/v2/markets", "", function(payload, tonce){
		//console.log(payload);
		var uri = "markets?access_key=" + exports.accessKey + "&tonce=" + tonce + "&signature=" + payload;
		exports.apiRequest(uri, function(result){
			if(result.success){
				return callback(JSON.parse(result.message));
			}else{
				return callback(JSON.parse(result.error));	
			}
		})
	});	
}

//allMarketsTicker 
//Get ticker of all markets
/*
allMarketsTicker(function(res){
	if(!res.error){
		console.log(res);
	}else{
		console.log("ERROR: " + res)
	}
});
*/
exports.allMarketsTicker = function(callback){
		var uri = "tickers";
		exports.apiRequest(uri, function(result){
			if(result.success){
				return callback(JSON.parse(result.message));
				//console.log(result.message);
			}else{
				return callback(JSON.parse(result.error));	
				//console.log(result.error);

			}
		})
}

//ticker
//Get ticker of specific moment
/*
ticker("onzbtc", function(res){
	if(!res.error){
		console.log(res);
	}else{
		console.log("ERROR: " + res)
	}
});
*/
exports.ticker = function(market, callback){
		var uri = "tickers/" + market;
		exports.apiRequest(uri, function(result){
			if(result.success){
				//return callback(JSON.parse(result.message));
				console.log(result.message);
			}else{
				//return callback(JSON.parse(result.error));	
				console.log(result.error);

			}
		})
}

//account
//Get your profile and accounts info
/*
account(function(res){
	if(!res.error){
		console.log(res);
	}else{
		console.log("ERROR: " + res)
	}
});
*/
exports.account = function(callback){
	exports.genPayload("GET", "/api/v2/members/me", "", function(payload, tonce){
		//console.log(payload);
		var uri = "members/me?access_key=" + exports.accessKey + "&tonce=" + tonce + "&signature=" + payload;
		exports.apiRequest(uri, function(result){
			if(result.success){
				return callback(JSON.parse(result.message));
				//console.log(result.message);
			}else{
				return callback(JSON.parse(result.error));	
				//console.log(result.error);

			}
		})
	});	
}

//allDeposits
/*
allDeposits(function(res){
	if(!res.error){
		console.log(res);
	}else{
		console.log("ERROR: " + res)
	}
});
*/
exports.allDeposits = function(callback){
	exports.genPayload("GET", "/api/v2/deposits", "", function(payload, tonce){
		//console.log(payload);
		var uri = "deposits?access_key=" + exports.accessKey + "&tonce=" + tonce + "&signature=" + payload;
		exports.apiRequest(uri, function(result){
			if(result.success){
				return callback(JSON.parse(result.message));
				//console.log(result.message);
			}else{
				return callback(JSON.parse(result.error));	
				//console.log(result.error);

			}
		})
	});	
}

//deposits
//Get your deposits history
/*
deposits("onz", function(res){
	if(!res.error){
		console.log(res);
	}else{
		console.log("ERROR: " + res)
	}
});
*/
exports.deposits = function(currencySymbol, callback){
	exports.genPayload("GET", "/api/v2/deposits", "&currency=" + currencySymbol, function(payload, tonce){
		//console.log(payload);
		var uri = "deposits?access_key=" + exports.accessKey + "&currency=" + currencySymbol +"&tonce=" + tonce + "&signature=" + payload;
		exports.apiRequest(uri, function(result){
			if(result.success){
				return callback(JSON.parse(result.message));
				//console.log(result.message);
			}else{
				return callback(JSON.parse(result.error));	
				//console.log(result.error);

			}
		})
	});	
}

//deposit
//Get details of specific deposit
/*
deposit("1231232132131331313", function(res){
	if(!res.error){
		console.log(res);
	}else{
		console.log("ERROR: " + res)
	}
});
*/
exports.deposit = function(txid, callback){
	exports.genPayload("GET", "/api/v2/deposit", "&txid=" + txid, function(payload, tonce){
		//console.log(payload);
		var uri = "deposit?access_key=" + exports.accessKey + "&txid=" + txid + "&tonce=" + tonce + "&signature=" + payload;
		exports.apiRequest(uri, function(result){
			if(result.success){
				return callback(JSON.parse(result.message));
				//console.log(result.message);
			}else{
				return callback(JSON.parse(result.error));	
				//console.log(result.error);
			}
		})
	});	
}

//depositAddress
//Where to deposit. 
//The address field could be empty when a new address is generating (e.g. for bitcoin), you should try again later in that casee
/*
depositAddress("onz", function(res){
	if(!res.error){
		console.log(res);
	}else{
		console.log("ERROR: " + res)
	}
});
*/
exports.depositAddress = function(currencySymbol, callback){
	exports.genPayload("GET", "/api/v2/deposit_address", "&currency=" + currencySymbol, function(payload, tonce){
		//console.log(payload);
		var uri = "deposit_address?access_key=" + exports.accessKey + "&currency=" + currencySymbol + "&tonce=" + tonce + "&signature=" + payload;
		exports.apiRequest(uri, function(result){
			if(result.success){
				return callback(JSON.parse(result.message));
				//console.log(result.message);
			}else{
				return callback(JSON.parse(result.error));	
				//console.log(result.error);

			}
		})
	});	
}

//orders
//Get your orders for a market, results is paginated
/*
orders("onzbtc", function(res){
	if(!res.error){
		console.log(res);
	}else{
		console.log("ERROR: " + res)
	}
});
*/
exports.orders = function(market, callback){
	exports.genPayload("GET", "/api/v2/orders", "&market=" + market, function(payload, tonce){
		//console.log(payload);
		var uri = "orders?access_key=" + exports.accessKey + "&market=" + market + "&tonce=" + tonce + "&signature=" + payload;
		exports.apiRequest(uri, function(result){
			if(result.success){
				return callback(JSON.parse(result.message));
				//console.log(result.message);
			}else{
				return callback(JSON.parse(result.error));	
				//console.log(result.error);

			}
		})
	});	
}

//ordersAll
//Get ALL your orders, results is paginated
/*
ordersAll(function(res){
	if(!res.error){
		console.log(res);
	}else{
		console.log("ERROR: " + res)
	}
});
*/
exports.ordersAll = function(callback){
	exports.genPayload("GET", "/api/v2/orders", "&market=all", function(payload, tonce){
		//console.log(payload);
		var uri = "orders?access_key=" + exports.accessKey + "&market=all" + "&tonce=" + tonce + "&signature=" + payload;
		exports.apiRequest(uri, function(result){
			if(result.success){
				return callback(JSON.parse(result.message));
				//console.log(result.message);
			}else{
				return callback(JSON.parse(result.error));	
				//console.log(result.error);

			}
		})
	});	
}

//createOrder
//Create a Sell/Buy order
/*
createOrder("onzbtc", "buy", "5.0", "0.000000200", function(res){
	if(!res.error){
		console.log(res);
	}else{
		console.log("ERROR: " + res)
	}
});
*/
exports.createOrder = function(market, side, volume, price, callback){
	exports.tonce(function(tonce){
		var query = "access_key=" + exports.accessKey + "&market=" + market + "&price=" + price + "&side=" + side + "&tonce=" + tonce+ "&volume=" + volume ;
		exports.genPayloadNoTONCE("POST", "/api/v2/orders", query, function(payload){
			//console.log(payload);
			var uri = "orders?" + query;
			//console.log(uri);
			exports.apiPostRequest(uri, payload, function(result){
				if(result.success){
					return callback(JSON.parse(result.message));
					//console.log(result.message);
				}else{
					return callback(JSON.parse(result.error));	
					//console.log(result.error);	
				}
			})
		});	
	});

}

//Create multi Sell/Buy orders

//Cancel all my orders

//order
//Get infomation on specific order
/*
order("1406431", function(res){
	if(!res.error){
		console.log(res);
		console.log(res.state);
	}else{
		console.log("ERROR: " + res)
	}
});
*/
exports.order = function(id, callback){
	exports.genPayload("GET", "/api/v2/order", "&id=" + id, function(payload, tonce){
		//console.log(payload);
		var uri = "order?access_key=" + exports.accessKey + "&id=" + id + "&tonce=" + tonce + "&signature=" + payload;
		exports.apiRequest(uri, function(result){
			if(result.success){
				return callback(JSON.parse(result.message));
				//console.log(result.message);
			}else{
				return callback(JSON.parse(result.error));	
				//console.log(result.error);

			}
		})
	});	
}

//cancelOrder
//Cancel a order
/*
cancelOrder("1406431", function(res){
	if(!res.error){
		console.log(res);
		console.log(res.state);
	}else{
		console.log("ERROR: " + res)
	}
});
*/
exports.cancelOrder = function(id, callback){
	exports.tonce(function(tonce){
		var query = "access_key=" + exports.accessKey + "&id=" + id + "&tonce=" + tonce;
		exports.genPayloadNoTONCE("POST", "/api/v2/order/delete", query, function(payload){
			//console.log(payload);
			var uri = "order/delete?" + query;
			//console.log(uri);
			exports.apiPostRequest(uri, payload, function(result){
				if(result.success){
					return callback(JSON.parse(result.message));
					//console.log(result.message);
				}else{
					return callback(JSON.parse(result.error));	
					//console.log(result.error);	
				}
			})
		});	
	});

}

//clearAllOrdersSide
//Clear all orders on a side buy/sell bids/asks
/*
clearAllOrdersSide("bids", function(res){
	if(!res.error){
		console.log(res);
	}else{
		console.log(res)
	}
});
*/
exports.clearAllOrdersSide = function(side, callback){
	exports.tonce(function(tonce){
		var query = "access_key=" + exports.accessKey + "&side=" + side + "&tonce=" + tonce;
		exports.genPayloadNoTONCE("POST", "/api/v2/orders/clear", query, function(payload){
			//console.log(payload);
			var uri = "orders/clear?" + query;
			//console.log(uri);
			exports.apiPostRequest(uri, payload, function(result){
				if(result.success){
					return callback(JSON.parse(result.message));
					//console.log(result.message);
				}else{
					return callback(JSON.parse(result.error));	
					//console.log(result.error);	
				}
			})
		});	
	});

}

//clearAllOrdersSide
//Clear all orders on a side buy/sell bids/asks
/*
clearAllOrders(function(res){
	if(!res.error){
		console.log(res);
	}else{
		console.log(res)
	}
});
*/
exports.clearAllOrders = function(callback){
	exports.tonce(function(tonce){
		var query = "access_key=" + exports.accessKey + "&tonce=" + tonce;
		exports.genPayloadNoTONCE("POST", "/api/v2/orders/clear", query, function(payload){
			//console.log(payload);
			var uri = "orders/clear?" + query;
			//console.log(uri);
			exports.apiPostRequest(uri, payload, function(result){
				if(result.success){
					return callback(JSON.parse(result.message));
					//console.log(result.message);
				}else{
					return callback(JSON.parse(result.error));	
					//console.log(result.error);	
				}
			})
		});	
	});

}

//orderBook
//Get the order book of specified market
/*
orderBook("onzbtc", function(res){
	if(!res.error){
		console.log(res);
	}else{
		console.log("ERROR: " + res)
	}
});
*/
exports.orderBook = function(market, callback){
	exports.genPayload("GET", "/api/v2/order_book", "&market=" + market, function(payload, tonce){
		//console.log(payload);
		var uri = "order_book?access_key=" + exports.accessKey + "&market=" + market + "&tonce=" + tonce + "&signature=" + payload;
		exports.apiRequest(uri, function(result){
			if(result.success){
				return callback(JSON.parse(result.message));
				//console.log(result.message);
			}else{
				return callback(JSON.parse(result.error));	
				//console.log(result.error);

			}
		})
	});	
}

//depth
//Get depth or specified market. Both asks and bids are sorted from highest price to lowest
/*
depth("onzbtc", function(res){
	if(!res.error){
		console.log(res);
	}else{
		console.log("ERROR: " + res)
	}
});
*/
exports.depth = function(market, callback){
	exports.genPayload("GET", "/api/v2/depth", "&market=" + market, function(payload, tonce){
		//console.log(payload);
		var uri = "depth?access_key=" + exports.accessKey + "&market=" + market + "&tonce=" + tonce + "&signature=" + payload;
		exports.apiRequest(uri, function(result){
			if(result.success){
				return callback(JSON.parse(result.message));
				//console.log(result.message);
			}else{
				return callback(JSON.parse(result.error));	
				//console.log(result.error);

			}
		})
	});	
}

//trades
//Get recent trades on market, each trade is included only once. Trades are sorted in reverse creation order
/*
trades("onzbtc", function(res){
	if(!res.error){
		console.log(res);
	}else{
		console.log("ERROR: " + res)
	}
});
*/
exports.trades = function(market, callback){
	exports.genPayload("GET", "/api/v2/trades", "&market=" + market, function(payload, tonce){
		//console.log(payload);
		var uri = "trades?access_key=" + exports.accessKey + "&market=" + market + "&tonce=" + tonce + "&signature=" + payload;
		exports.apiRequest(uri, function(result){
			if(result.success){
				return callback(JSON.parse(result.message));
				//console.log(result.message);
			}else{
				return callback(JSON.parse(result.error));	
				//console.log(result.error);

			}
		})
	});	
}

//myTrades
//Get your executed trades. Trades are sorted in reverse creation order.
/*
myTrades("onzbtc", function(res){
	if(!res.error){
		console.log(res);
	}else{
		console.log("ERROR: " + res)
	}
});
*/
exports.myTrades = function(market, callback){
	exports.genPayload("GET", "/api/v2/trades/my", "&market=" + market, function(payload, tonce){
		//console.log(payload);
		var uri = "trades/my?access_key=" + exports.accessKey + "&market=" + market + "&tonce=" + tonce + "&signature=" + payload;
		exports.apiRequest(uri, function(result){
			if(result.success){
				return callback(JSON.parse(result.message));
				//console.log(result.message);
			}else{
				return callback(JSON.parse(result.error));	
				//console.log(result.error);

			}
		})
	});	
}

//Open High Low Close K Line
//Get OHLC(k line) of specific market.
/*
kLine("onzbtc", function(res){
	if(!res.error){
		console.log(res);
	}else{
		console.log("ERROR: " + res)
	}
});
*/
exports.kLine = function(market, callback){
	exports.genPayload("GET", "/api/v2/k", "&market=" + market, function(payload, tonce){
		//console.log(payload);
		var uri = "k?access_key=" + exports.accessKey + "&market=" + market + "&tonce=" + tonce + "&signature=" + payload;
		exports.apiRequest(uri, function(result){
			if(result.success){
				return callback(JSON.parse(result.message));
				//console.log(result.message);
			}else{
				return callback(JSON.parse(result.error));	
				//console.log(result.error);

			}
		})
	});	
}

//timestamp
//Server current time in seconds since Unix epoch
/*
timestamp(function(res){
	if(!res.error){
		console.log(res);
	}else{
		console.log("ERROR: " + res)
	}
});
*/
exports.timestamp = function(callback){
		var uri = "timestamp";
		exports.apiRequest(uri, function(result){
			if(result.success){
				return callback(JSON.parse(result.message));
				//console.log(result.message);
			}else{
				return callback(JSON.parse(result.error));	
				//console.log(result.error);

			}
		})	
}

// TO DO:
// 1) Need to extend with some extra options/params certain API calls can take, left to defaults
// 2) left out: k_with_pending_trades
// -Scott













